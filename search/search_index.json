{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"What I cannot create, I do not understand Projects: Skills","text_tokens":["create"," ","what","not","understand","do","i","projects","cannot",",",":","skills"],"title":"Resume","title_tokens":["resume"]},{"location":"#what-i-cannot-create-i-do-not-understand","text":"","text_tokens":[],"title":"What I cannot create, I do not understand","title_tokens":["create"," ","what","not","understand","do","i","cannot",","]},{"location":"#projects","text":"","text_tokens":[],"title":"Projects:","title_tokens":["projects",":"]},{"location":"#skills","text":"","text_tokens":[],"title":"Skills","title_tokens":["skills"]},{"location":"Projects/","text":"","text_tokens":[],"title":"Projects","title_tokens":["projects"]},{"location":"Skills/","text":"codes for algorithms keras 参考： https://keras.io/ Setup import numpy as np import tensorflow as tf from tensorflow import keras Data loading Keras models accept three types of inputs: NumPy arrays , just like Scikit-Learn and many other Python-based libraries. This is a good option if your data fits in memory. TensorFlow Dataset objects . This is a high-performance option that is more suitable for datasets that do not fit in memory and that are streamed from disk or from a distributed filesystem. Python generators that yield batches of data (such as custom subclasses of the keras.utils.Sequence class). Keras features a range of utilities to help you turn raw data on disk into a Dataset : tf.keras.preprocessing.image_dataset_from_directory turns image files sorted into class-specific folders into a labeled dataset of image tensors. tf.keras.preprocessing.text_dataset_from_directory does the same for text files. In addition, the TensorFlow tf.data includes other similar utilities, such as tf.data.experimental.make_csv_dataset to load structured data from CSV files. Supposed you have image files sorted by class in different folders, like this: main_directory/ ...class_a/ ......a_image_1.jpg ......a_image_2.jpg ...class_b/ ......b_image_1.jpg ......b_image_2.jpg Then you can do: # Create a dataset. dataset = keras.preprocessing.image_dataset_from_directory( 'path/to/main_directory', batch_size=64, image_size=(200, 200)) # For demonstration, iterate over the batches yielded by the dataset. for data, labels in dataset: print(data.shape) # (64, 200, 200, 3) print(data.dtype) # float32 print(labels.shape) # (64,) print(labels.dtype) # int32 The label of a sample is the rank of its folder in alphanumeric order. Naturally, this can also be configured explicitly by passing, e.g. class_names=['class_a', 'class_b'] , in which cases label 0 will be class_a and 1 will be class_b . Example: obtaining a labeled dataset from text files on disk Likewise for text: if you have .txt documents sorted by class in different folders, you can do: dataset = keras.preprocessing.text_dataset_from_directory( 'path/to/main_directory', batch_size=64) # For demonstration, iterate over the batches yielded by the dataset. for data, labels in dataset: print(data.shape) # (64,) print(data.dtype) # string print(labels.shape) # (64,) print(labels.dtype) # int32 Data preprocessing with Keras Using Keras preprocessing layers In Keras, you do in-model data preprocessing via preprocessing layers . This includes: Vectorizing raw strings of text via the TextVectorization layer Feature normalization via the Normalization layer Image rescaling, cropping, or image data augmentation Example: turning strings into sequences of integer word indices from tensorflow.keras.layers.experimental.preprocessing import TextVectorization # Example training data, of dtype `string`. training_data = np.array([[\"This is the 1st sample.\"], [\"And here's the 2nd sample.\"]]) # Create a TextVectorization layer instance. It can be configured to either # return integer token indices, or a dense token representation (e.g. multi-hot # or TF-IDF). The text standardization and text splitting algorithms are fully # configurable. vectorizer = TextVectorization(output_mode=\"int\") # Calling `adapt` on an array or dataset makes the layer generate a vocabulary # index for the data, which can then be reused when seeing new data. vectorizer.adapt(training_data) # After calling adapt, the layer is able to encode any n-gram it has seen before # in the `adapt()` data. Unknown n-grams are encoded via an \"out-of-vocabulary\" # token. integer_data = vectorizer(training_data) print(integer_data) tf.Tensor( [[4 5 2 9 3] [7 6 2 8 3]], shape=(2, 5), dtype=int64) Example: turning strings into sequences of one-hot encoded bigrams from tensorflow.keras.layers.experimental.preprocessing import TextVectorization # Example training data, of dtype `string`. training_data = np.array([[\"This is the 1st sample.\"], [\"And here's the 2nd sample.\"]]) # Create a TextVectorization layer instance. It can be configured to either # return integer token indices, or a dense token representation (e.g. multi-hot # or TF-IDF). The text standardization and text splitting algorithms are fully # configurable. vectorizer = TextVectorization(output_mode=\"binary\", ngrams=2) # Calling `adapt` on an array or dataset makes the layer generate a vocabulary # index for the data, which can then be reused when seeing new data. vectorizer.adapt(training_data) # After calling adapt, the layer is able to encode any n-gram it has seen before # in the `adapt()` data. Unknown n-grams are encoded via an \"out-of-vocabulary\" # token. integer_data = vectorizer(training_data) print(integer_data) tf.Tensor( [[0. 1. 1. 1. 1. 0. 1. 1. 1. 0. 0. 0. 0. 0. 0. 1. 1.] [0. 1. 1. 0. 0. 1. 0. 0. 0. 1. 1. 1. 1. 1. 1. 0. 0.]], shape=(2, 17), dtype=float32) Example: normalizing features from tensorflow.keras.layers.experimental.preprocessing import Normalization # Example image data, with values in the [0, 255] range training_data = np.random.randint(0, 256, size=(64, 200, 200, 3)).astype(\"float32\") normalizer = Normalization(axis=-1) normalizer.adapt(training_data) normalized_data = normalizer(training_data) print(\"var: %.4f\" % np.var(normalized_data)) print(\"mean: %.4f\" % np.mean(normalized_data)) var: 1.0000 mean: 0.0000 Example: rescaling & center-cropping images Both the Rescaling layer and the CenterCrop layer are stateless, so it isn't necessary to call adapt() in this case. from tensorflow.keras.layers.experimental.preprocessing import CenterCrop from tensorflow.keras.layers.experimental.preprocessing import Rescaling # Example image data, with values in the [0, 255] range training_data = np.random.randint(0, 256, size=(64, 200, 200, 3)).astype(\"float32\") cropper = CenterCrop(height=150, width=150) scaler = Rescaling(scale=1.0 / 255) output_data = scaler(cropper(training_data)) print(\"shape:\", output_data.shape) print(\"min:\", np.min(output_data)) print(\"max:\", np.max(output_data)) shape: (64, 150, 150, 3) min: 0.0 max: 1.0 Building models with the Keras Functional API For instance, here's a linear projection layer that maps its inputs to a 16-dimensional feature space: dense = keras.layers.Dense(units=16) The most common and most powerful way to build Keras models is the Functional API. # Let's say we expect our inputs to be RGB images of arbitrary size inputs = keras.Input(shape=(None, None, 3)) After defining your input(s), you chain layer transformations on top of your inputs, until your final output: from tensorflow.keras import layers # Center-crop images to 150x150 x = CenterCrop(height=150, width=150)(inputs) # Rescale images to [0, 1] x = Rescaling(scale=1.0 / 255)(x) # Apply some convolution and pooling layers x = layers.Conv2D(filters=32, kernel_size=(3, 3), activation=\"relu\")(x) x = layers.MaxPooling2D(pool_size=(3, 3))(x) x = layers.Conv2D(filters=32, kernel_size=(3, 3), activation=\"relu\")(x) x = layers.MaxPooling2D(pool_size=(3, 3))(x) x = layers.Conv2D(filters=32, kernel_size=(3, 3), activation=\"relu\")(x) # Apply global average pooling to get flat feature vectors x = layers.GlobalAveragePooling2D()(x) # Add a dense classifier on top num_classes = 10 outputs = layers.Dense(num_classes, activation=\"softmax\")(x) Once you have defined the directed acyclic graph of layers that turns your input(s) into your outputs, instantiate a Model object: model = keras.Model(inputs=inputs, outputs=outputs) This model behaves basically like a bigger layer. You can call it on batches of data, like this: data = np.random.randint(0, 256, size=(64, 200, 200, 3)).astype(\"float32\") processed_data = model(data) print(processed_data.shape) (64, 10) You can print a summary of how your data gets transformed at each stage of the model. This is useful for debugging. Note that the output shape displayed for each layer includes the batch size . Here the batch size is None, which indicates our model can process batches of any size. model.summary() Model: \"functional_1\" _________________________________________________________________ Layer (type) Output Shape Param # ================================================================= input_1 (InputLayer) [(None, None, None, 3)] 0 _________________________________________________________________ center_crop_1 (CenterCrop) (None, 150, 150, 3) 0 _________________________________________________________________ rescaling_1 (Rescaling) (None, 150, 150, 3) 0 _________________________________________________________________ conv2d (Conv2D) (None, 148, 148, 32) 896 _________________________________________________________________ max_pooling2d (MaxPooling2D) (None, 49, 49, 32) 0 _________________________________________________________________ conv2d_1 (Conv2D) (None, 47, 47, 32) 9248 _________________________________________________________________ max_pooling2d_1 (MaxPooling2 (None, 15, 15, 32) 0 _________________________________________________________________ conv2d_2 (Conv2D) (None, 13, 13, 32) 9248 _________________________________________________________________ global_average_pooling2d (Gl (None, 32) 0 _________________________________________________________________ dense (Dense) (None, 10) 330 ================================================================= Total params: 19,722 Trainable params: 19,722 Non-trainable params: 0 _________________________________________________________________ The Functional API also makes it easy to build models that have multiple inputs (for instance, an image and its metadata) or multiple outputs (for instance, predicting the class of the image and the likelihood that a user will click on it). For a deeper dive into what you can do, see our guide to the Functional API . Training models with fit() Before you can call fit() , you need to specify an optimizer and a loss function (we assume you are already familiar with these concepts). This is the compile() step: model.compile(optimizer=keras.optimizers.RMSprop(learning_rate=1e-3), loss=keras.losses.CategoricalCrossentropy()) Loss and optimizer can be specified via their string identifiers (in this case their default constructor argument values are used): model.compile(optimizer='rmsprop', loss='categorical_crossentropy') Once your model is compiled, you can start \"fitting\" the model to the data. Here's what fitting a model looks like with NumPy data: model.fit(numpy_array_of_samples, numpy_array_of_labels, batch_size=32, epochs=10) Besides the data, you have to specify two key parameters: the batch_size and the number of epochs (iterations on the data). Here our data will get sliced on batches of 32 samples, and the model will iterate 10 times over the data during training. Here's what fitting a model looks like with a dataset: model.fit(dataset_of_samples_and_labels, epochs=10) Since the data yielded by a dataset is expect to be already batched, you don't need to specify the batch size here. Let's look at it in practice with a toy example model that learns to classify MNIST digits: # Get the data as Numpy arrays (x_train, y_train), (x_test, y_test) = keras.datasets.mnist.load_data() # Build a simple model inputs = keras.Input(shape=(28, 28)) x = layers.experimental.preprocessing.Rescaling(1.0 / 255)(inputs) x = layers.Flatten()(x) x = layers.Dense(128, activation=\"relu\")(x) x = layers.Dense(128, activation=\"relu\")(x) outputs = layers.Dense(10, activation=\"softmax\")(x) model = keras.Model(inputs, outputs) model.summary() # Compile the model model.compile(optimizer=\"adam\", loss=\"sparse_categorical_crossentropy\") # Train the model for 1 epoch from Numpy data batch_size = 64 print(\"Fit on NumPy data\") history = model.fit(x_train, y_train, batch_size=batch_size, epochs=1) # Train the model for 1 epoch using a dataset dataset = tf.data.Dataset.from_tensor_slices((x_train, y_train)).batch(batch_size) print(\"Fit on Dataset\") history = model.fit(dataset, epochs=1) Model: \"functional_3\" _________________________________________________________________ Layer (type) Output Shape Param # ================================================================= input_2 (InputLayer) [(None, 28, 28)] 0 _________________________________________________________________ rescaling_2 (Rescaling) (None, 28, 28) 0 _________________________________________________________________ flatten (Flatten) (None, 784) 0 _________________________________________________________________ dense_1 (Dense) (None, 128) 100480 _________________________________________________________________ dense_2 (Dense) (None, 128) 16512 _________________________________________________________________ dense_3 (Dense) (None, 10) 1290 ================================================================= Total params: 118,282 Trainable params: 118,282 Non-trainable params: 0 _________________________________________________________________ Fit on NumPy data 938/938 [==============================] - 1s 1ms/step - loss: 0.2671 Fit on Dataset 938/938 [==============================] - 1s 1ms/step - loss: 0.1156 The fit() call returns a \"history\" object which records what happened over the course of training. The history.history dict contains per-epoch timeseries of metrics values (here we have only one metric, the loss, and one epoch, so we only get a single scalar): print(history.history) {'loss': [0.11557048559188843]} For a detailed overview of how to use fit() , see the guide to training & evaluation with the built-in Keras methods . games： 参考： https://www.zhihu.com/question/36702693 输出：？","text_tokens":["：","subclasses","unknown","powerful","print","option","performance","15","add","can","calling","methods",",","chain","evaluation","it","sample","load","does","this","that","sequences","setup","final","1290","help","16","metrics","normalizing","bigrams","use","disk","0","9","guide","one","demonstration","already","encode","num","labels","width","size","top","trainable","say","330","detailed","maxpooling2d","rgb","necessary","e","case","functional","6","}","have","'","what","outputs","conv2d","utils","debugging","relu","likewise","from","contains","pooling2d","vectorizer","is","linear","or","our","keras","graph","objects","string","adapt","look","utilities","int32","int","predicting","activation","get","configurable","astype","function","documents","filesystem","classify","for","then","arbitrary","io","used","rank","cropper","passing","epochs","standardization","pooling","x","streamed","splitting","looks","2nd","useful","148","single","17","alphanumeric","dense","rescale","categorical","100480","txt","different","memory","150","28","rescaling","text","times","step","784","return","augmentation","structured","expect","labeled","images","indicates","folders","cropping","suitable","49","summary","kernel","codes","makes","datasets","some","with","loading","has","stage","layer","crossentropy","crop","generate","10","many","a","batch","instance","representation","encoded","each",".","good","libraries","feature","common","constructor","compiled","via","timeseries","classes","will","s","pool","scaler","softmax","acyclic","note","raw","and","int64","be","toy","random","dtype","easy","both","example","before","instantiate","train","projection","course","likelihood","www","0.0","_________________________________________________________________","rmsprop","multiple","space","types","similar","%.","bigger","......","iterate","stateless","range","arrays","params","these","fits","5","sparse","specific","assume","displayed","seen","indices","flatten","reused","globalaveragepooling2d","https","9248","create","iterations","as","zhihu","directory","36702693","hot","np","32","records","naturally","python","layers","randint","yielded","938","api","sequence","0.0000","are","cases","gram","normalization","if","in","order","sorted","your","=","idf","com","same","param","such","two","explicitly","loss","yield","axis","convolution","tensor","at","numpy","until","gets","digits","center","turn","number","dataset","class","centercrop","-","any","key","call","just","13","grams","here","custom","addition","like","compile","parameters","maxpooling2","which","units","7","see","256","on","normalizer","default","strings","object","main","of","inputs","输出","data","built","722","150x150","concepts","image","y","fully","how","type","multi","deeper","1st","optimizers","filters","1s","practice","output","vocabulary","{","non","build","its","vectors","%","since","per","includes","preprocessing","mean","ngrams","learn","2","]","samples","1","based",")","inputlayer","isn","also","batches","vectorizing","argument","games","csv","their","1e","128","new","min","categoricalcrossentropy","out","fitting","question","array","behaves","float32","more","&","[","process","test","batched","basically","tensorflow","word","normalized","the","max","sliced","flat","turning","mnist"," ","896","building","configured","generators","when","history","specify","scale","don","118","3","0.11557048559188843",":","t","folder","4f","to","_","epoch","overview","so","binary","over","64","integer","besides","47","/","algorithms","names","we","losses","three","jpg","during","none","only","transformations","transformed","familiar","rate","0.2671","global","need","tf","models","metric","label","dict","most","8","simple","#","4","after","index","high","defined","adam","total","once","learning","able","way","values","参考","dive","make","using","import","height","identifiers","by","(","optimizer","gl","supposed","dimensional","experimental","not","1ms","b","token","into","turns","directed","files","learns","shape","you","either","other","happened","training","let","16512","features","200","1.0000","click","slices","accept","255","defining","fit","seeing","scikit","returns","processed","1.0","an","do","mode","n","282","g","model","path","user","textvectorization","tensors","input","...","scalar","apply","specified","classifier","average","\"","obtaining","var","distributed","19","metadata","0.1156","maps","start","`","？"],"title":"Skills","title_tokens":["skills"]},{"location":"Skills/#codes-for-algorithms","text":"","text_tokens":[],"title":"codes for algorithms","title_tokens":["codes","for","algorithms"," "]},{"location":"Skills/#keras","text":"参考： https://keras.io/","text_tokens":["：","/","io"," ",".","参考","https",":","keras"],"title":"keras","title_tokens":["keras"]},{"location":"Skills/#setup","text":"import numpy as np import tensorflow as tf from tensorflow import keras","text_tokens":["numpy","tf"," ","tensorflow","as","np","import","from","keras"],"title":"Setup","title_tokens":["setup"]},{"location":"Skills/#data-loading","text":"Keras models accept three types of inputs: NumPy arrays , just like Scikit-Learn and many other Python-based libraries. This is a good option if your data fits in memory. TensorFlow Dataset objects . This is a high-performance option that is more suitable for datasets that do not fit in memory and that are streamed from disk or from a distributed filesystem. Python generators that yield batches of data (such as custom subclasses of the keras.utils.Sequence class). Keras features a range of utilities to help you turn raw data on disk into a Dataset : tf.keras.preprocessing.image_dataset_from_directory turns image files sorted into class-specific folders into a labeled dataset of image tensors. tf.keras.preprocessing.text_dataset_from_directory does the same for text files. In addition, the TensorFlow tf.data includes other similar utilities, such as tf.data.experimental.make_csv_dataset to load structured data from CSV files. Supposed you have image files sorted by class in different folders, like this: main_directory/ ...class_a/ ......a_image_1.jpg ......a_image_2.jpg ...class_b/ ......b_image_1.jpg ......b_image_2.jpg Then you can do: # Create a dataset. dataset = keras.preprocessing.image_dataset_from_directory( 'path/to/main_directory', batch_size=64, image_size=(200, 200)) # For demonstration, iterate over the batches yielded by the dataset. for data, labels in dataset: print(data.shape) # (64, 200, 200, 3) print(data.dtype) # float32 print(labels.shape) # (64,) print(labels.dtype) # int32 The label of a sample is the rank of its folder in alphanumeric order. Naturally, this can also be configured explicitly by passing, e.g. class_names=['class_a', 'class_b'] , in which cases label 0 will be class_a and 1 will be class_b . Example: obtaining a labeled dataset from text files on disk Likewise for text: if you have .txt documents sorted by class in different folders, you can do: dataset = keras.preprocessing.text_dataset_from_directory( 'path/to/main_directory', batch_size=64) # For demonstration, iterate over the batches yielded by the dataset. for data, labels in dataset: print(data.shape) # (64,) print(data.dtype) # string print(labels.shape) # (64,) print(labels.dtype) # int32","text_tokens":["subclasses","your","labeled","=","option","print","order","performance","folders","3",":","suitable","folder","to","same","_","can","such","explicitly","yield",",","datasets","over","64","sample","numpy","/","load","does","names","turn","this","three","dataset","that","jpg","class","many","-","just","help","a","batch",".","good","tf","disk","0","models","custom","addition","like","libraries","label","which","on","#","demonstration","high","labels","size","will","main","of","inputs","data","make","e","have","image","by","(","'","raw","and","utils","be","supposed","likewise","from","dtype","experimental","structured","not","is","example","or","b","into","keras","turns","objects","files","string","utilities","int32","its","shape","you","other","documents","types","filesystem","features","similar","includes","preprocessing","......","200","iterate","for","arrays","range","then","learn","2","]","rank","accept","fits","1","passing","based",")","fit","also","batches","scikit","specific","streamed","csv","do","g","create","path","as","float32","more","directory","alphanumeric","[","naturally","tensors","python","...","tensorflow","the","yielded","txt","different","memory","sequence","obtaining","are","text","distributed"," ","cases","if","configured","in","generators","sorted"],"title":"Data loading","title_tokens":["loading"," ","data"]},{"location":"Skills/#data-preprocessing-with-keras","text":"Using Keras preprocessing layers In Keras, you do in-model data preprocessing via preprocessing layers . This includes: Vectorizing raw strings of text via the TextVectorization layer Feature normalization via the Normalization layer Image rescaling, cropping, or image data augmentation Example: turning strings into sequences of integer word indices from tensorflow.keras.layers.experimental.preprocessing import TextVectorization # Example training data, of dtype `string`. training_data = np.array([[\"This is the 1st sample.\"], [\"And here's the 2nd sample.\"]]) # Create a TextVectorization layer instance. It can be configured to either # return integer token indices, or a dense token representation (e.g. multi-hot # or TF-IDF). The text standardization and text splitting algorithms are fully # configurable. vectorizer = TextVectorization(output_mode=\"int\") # Calling `adapt` on an array or dataset makes the layer generate a vocabulary # index for the data, which can then be reused when seeing new data. vectorizer.adapt(training_data) # After calling adapt, the layer is able to encode any n-gram it has seen before # in the `adapt()` data. Unknown n-grams are encoded via an \"out-of-vocabulary\" # token. integer_data = vectorizer(training_data) print(integer_data) tf.Tensor( [[4 5 2 9 3] [7 6 2 8 3]], shape=(2, 5), dtype=int64) Example: turning strings into sequences of one-hot encoded bigrams from tensorflow.keras.layers.experimental.preprocessing import TextVectorization # Example training data, of dtype `string`. training_data = np.array([[\"This is the 1st sample.\"], [\"And here's the 2nd sample.\"]]) # Create a TextVectorization layer instance. It can be configured to either # return integer token indices, or a dense token representation (e.g. multi-hot # or TF-IDF). The text standardization and text splitting algorithms are fully # configurable. vectorizer = TextVectorization(output_mode=\"binary\", ngrams=2) # Calling `adapt` on an array or dataset makes the layer generate a vocabulary # index for the data, which can then be reused when seeing new data. vectorizer.adapt(training_data) # After calling adapt, the layer is able to encode any n-gram it has seen before # in the `adapt()` data. Unknown n-grams are encoded via an \"out-of-vocabulary\" # token. integer_data = vectorizer(training_data) print(integer_data) tf.Tensor( [[0. 1. 1. 1. 1. 0. 1. 1. 1. 0. 0. 0. 0. 0. 0. 1. 1.] [0. 1. 1. 0. 0. 1. 0. 0. 0. 1. 1. 1. 1. 1. 1. 0. 0.]], shape=(2, 17), dtype=float32) Example: normalizing features from tensorflow.keras.layers.experimental.preprocessing import Normalization # Example image data, with values in the [0, 255] range training_data = np.random.randint(0, 256, size=(64, 200, 200, 3)).astype(\"float32\") normalizer = Normalization(axis=-1) normalizer.adapt(training_data) normalized_data = normalizer(training_data) print(\"var: %.4f\" % np.var(normalized_data)) print(\"mean: %.4f\" % np.mean(normalized_data)) var: 1.0000 mean: 0.0000 Example: rescaling & center-cropping images Both the Rescaling layer and the CenterCrop layer are stateless, so it isn't necessary to call adapt() in this case. from tensorflow.keras.layers.experimental.preprocessing import CenterCrop from tensorflow.keras.layers.experimental.preprocessing import Rescaling # Example image data, with values in the [0, 255] range training_data = np.random.randint(0, 256, size=(64, 200, 200, 3)).astype(\"float32\") cropper = CenterCrop(height=150, width=150) scaler = Rescaling(scale=1.0 / 255) output_data = scaler(cropper(training_data)) print(\"shape:\", output_data.shape) print(\"min:\", np.min(output_data)) print(\"max:\", np.max(output_data)) shape: (64, 150, 150, 3) min: 0.0 max: 1.0","text_tokens":["unknown","scale","images","=","print","idf","3",":","t","cropping","4f","to","augmentation","_","can","calling","so","binary",",","makes","axis","64","integer","sample","it","tensor","with","/","algorithms","center","has","this","dataset","layer","sequences","generate","centercrop","-","any","call","a","instance","representation","encoded",".","normalizing","bigrams","tf","0","grams","here","9","feature","8","which","7","one","256","via","on","#","4","after","index","encode","normalizer","strings","size","width","of","s","data","able","values","scaler","necessary","e","using","case","import","6","height","image","(","'","raw","and","fully","int64","multi","be","random","1st","from","dtype","experimental","both","vectorizer","example","is","or","token","before","into","keras","output","string","vocabulary","adapt","int","0.0","either","you","shape","training","%","configurable","astype","%.","features","includes","preprocessing","mean","200","1.0000","stateless","for","ngrams","then","range","]","2","cropper","1","255","standardization","5",")","isn","seeing","vectorizing","1.0","splitting","an","seen","indices","do","mode","reused","n","new","min","out","g","2nd","model","create","array","float32","textvectorization","17","hot","np","&","dense","[","layers","randint","tensorflow","word","normalized","the","max","\"","150","rescaling","0.0000","var","text","are","turning"," ","gram","normalization","configured","return","`","in","when"],"title":"Data preprocessing with Keras","title_tokens":["with"," ","data","preprocessing","keras"]},{"location":"Skills/#building-models-with-the-keras-functional-api","text":"For instance, here's a linear projection layer that maps its inputs to a 16-dimensional feature space: dense = keras.layers.Dense(units=16) The most common and most powerful way to build Keras models is the Functional API. # Let's say we expect our inputs to be RGB images of arbitrary size inputs = keras.Input(shape=(None, None, 3)) After defining your input(s), you chain layer transformations on top of your inputs, until your final output: from tensorflow.keras import layers # Center-crop images to 150x150 x = CenterCrop(height=150, width=150)(inputs) # Rescale images to [0, 1] x = Rescaling(scale=1.0 / 255)(x) # Apply some convolution and pooling layers x = layers.Conv2D(filters=32, kernel_size=(3, 3), activation=\"relu\")(x) x = layers.MaxPooling2D(pool_size=(3, 3))(x) x = layers.Conv2D(filters=32, kernel_size=(3, 3), activation=\"relu\")(x) x = layers.MaxPooling2D(pool_size=(3, 3))(x) x = layers.Conv2D(filters=32, kernel_size=(3, 3), activation=\"relu\")(x) # Apply global average pooling to get flat feature vectors x = layers.GlobalAveragePooling2D()(x) # Add a dense classifier on top num_classes = 10 outputs = layers.Dense(num_classes, activation=\"softmax\")(x) Once you have defined the directed acyclic graph of layers that turns your input(s) into your outputs, instantiate a Model object: model = keras.Model(inputs=inputs, outputs=outputs) This model behaves basically like a bigger layer. You can call it on batches of data, like this: data = np.random.randint(0, 256, size=(64, 200, 200, 3)).astype(\"float32\") processed_data = model(data) print(processed_data.shape) (64, 10) You can print a summary of how your data gets transformed at each stage of the model. This is useful for debugging. Note that the output shape displayed for each layer includes the batch size . Here the batch size is None, which indicates our model can process batches of any size. model.summary() Model: \"functional_1\" _________________________________________________________________ Layer (type) Output Shape Param # ================================================================= input_1 (InputLayer) [(None, None, None, 3)] 0 _________________________________________________________________ center_crop_1 (CenterCrop) (None, 150, 150, 3) 0 _________________________________________________________________ rescaling_1 (Rescaling) (None, 150, 150, 3) 0 _________________________________________________________________ conv2d (Conv2D) (None, 148, 148, 32) 896 _________________________________________________________________ max_pooling2d (MaxPooling2D) (None, 49, 49, 32) 0 _________________________________________________________________ conv2d_1 (Conv2D) (None, 47, 47, 32) 9248 _________________________________________________________________ max_pooling2d_1 (MaxPooling2 (None, 15, 15, 32) 0 _________________________________________________________________ conv2d_2 (Conv2D) (None, 13, 13, 32) 9248 _________________________________________________________________ global_average_pooling2d (Gl (None, 32) 0 _________________________________________________________________ dense (Dense) (None, 10) 330 ================================================================= Total params: 19,722 Trainable params: 19,722 Non-trainable params: 0 _________________________________________________________________ The Functional API also makes it easy to build models that have multiple inputs (for instance, an image and its metadata) or multiple outputs (for instance, predicting the class of the image and the likelihood that a user will click on it). For a deeper dive into what you can do, see our guide to the Functional API .","text_tokens":["scale","powerful","your","images","=","print","indicates","3",":","15","49","to","summary","_","kernel","add","can","param",",","chain","makes","some","convolution","it","64","at","47","until","/","gets","center","we","this","that","layer","stage","crop","class","none","final","centercrop","10","transformations","-","any","call","a","instance","transformed","16","batch","global","each",".","13","0","models","here","guide","like","most","maxpooling2","feature","common","units","which","see","256","on","#","after","defined","classes","num","trainable","width","size","top","object","total","say","of","will","s","inputs","once","330","pool","way","data","maxpooling2d","rgb","dive","722","functional","import","150x150","height","have","image","softmax","(","what","'","acyclic","note","and","how","outputs","conv2d","debugging","type","relu","be","gl","random","deeper","dimensional","from","filters","pooling2d","easy","is","linear","or","our","into","keras","turns","instantiate","graph","directed","output","projection","likelihood","predicting","non","build","its","shape","you","activation","vectors","_________________________________________________________________","multiple","get","let","astype","space","includes","bigger","200","click","for","params","arbitrary","]","2","1","255",")","defining","pooling","inputlayer","also","batches","x","processed","displayed","1.0","an","do","globalaveragepooling2d","useful","9248","model","148","behaves","float32","user","32","np","dense","rescale","[","process","input","basically","layers","randint","tensorflow","the","apply","classifier","max","api","average","\"","150","flat","rescaling","19"," ","metadata","896","maps","expect"],"title":"Building models with the Keras Functional API","title_tokens":["with"," ","the","models","building","functional","api","keras"]},{"location":"Skills/#training-models-with-fit","text":"Before you can call fit() , you need to specify an optimizer and a loss function (we assume you are already familiar with these concepts). This is the compile() step: model.compile(optimizer=keras.optimizers.RMSprop(learning_rate=1e-3), loss=keras.losses.CategoricalCrossentropy()) Loss and optimizer can be specified via their string identifiers (in this case their default constructor argument values are used): model.compile(optimizer='rmsprop', loss='categorical_crossentropy') Once your model is compiled, you can start \"fitting\" the model to the data. Here's what fitting a model looks like with NumPy data: model.fit(numpy_array_of_samples, numpy_array_of_labels, batch_size=32, epochs=10) Besides the data, you have to specify two key parameters: the batch_size and the number of epochs (iterations on the data). Here our data will get sliced on batches of 32 samples, and the model will iterate 10 times over the data during training. Here's what fitting a model looks like with a dataset: model.fit(dataset_of_samples_and_labels, epochs=10) Since the data yielded by a dataset is expect to be already batched, you don't need to specify the batch size here. Let's look at it in practice with a toy example model that learns to classify MNIST digits: # Get the data as Numpy arrays (x_train, y_train), (x_test, y_test) = keras.datasets.mnist.load_data() # Build a simple model inputs = keras.Input(shape=(28, 28)) x = layers.experimental.preprocessing.Rescaling(1.0 / 255)(inputs) x = layers.Flatten()(x) x = layers.Dense(128, activation=\"relu\")(x) x = layers.Dense(128, activation=\"relu\")(x) outputs = layers.Dense(10, activation=\"softmax\")(x) model = keras.Model(inputs, outputs) model.summary() # Compile the model model.compile(optimizer=\"adam\", loss=\"sparse_categorical_crossentropy\") # Train the model for 1 epoch from Numpy data batch_size = 64 print(\"Fit on NumPy data\") history = model.fit(x_train, y_train, batch_size=batch_size, epochs=1) # Train the model for 1 epoch using a dataset dataset = tf.data.Dataset.from_tensor_slices((x_train, y_train)).batch(batch_size) print(\"Fit on Dataset\") history = model.fit(dataset, epochs=1) Model: \"functional_3\" _________________________________________________________________ Layer (type) Output Shape Param # ================================================================= input_2 (InputLayer) [(None, 28, 28)] 0 _________________________________________________________________ rescaling_2 (Rescaling) (None, 28, 28) 0 _________________________________________________________________ flatten (Flatten) (None, 784) 0 _________________________________________________________________ dense_1 (Dense) (None, 128) 100480 _________________________________________________________________ dense_2 (Dense) (None, 128) 16512 _________________________________________________________________ dense_3 (Dense) (None, 10) 1290 ================================================================= Total params: 118,282 Trainable params: 118,282 Non-trainable params: 0 _________________________________________________________________ Fit on NumPy data 938/938 [==============================] - 1s 1ms/step - loss: 0.2671 Fit on Dataset 938/938 [==============================] - 1s 1ms/step - loss: 0.1156 The fit() call returns a \"history\" object which records what happened over the course of training. The history.history dict contains per-epoch timeseries of metrics values (here we have only one metric, the loss, and one epoch, so we only get a single scalar): print(history.history) {'loss': [0.11557048559188843]} For a detailed overview of how to use fit() , see the guide to training & evaluation with the built-in Keras methods .","text_tokens":["specify","your","=","print","don","118","3","0.11557048559188843",":","t","to","summary","_","can","param","epoch","two","loss","so","overview","methods",",","over","datasets","evaluation","besides","it","64","at","tensor","with","numpy","/","load","digits","we","losses","this","number","dataset","that","layer","crossentropy","during","none","only","1290","10","-","key","call","a","familiar","rate","batch","0.2671","metrics",".","need","tf","use","0","metric","here","compile","like","parameters","dict","guide","constructor","which","simple","one","see","compiled","via","on","#","already","timeseries","default","adam","trainable","labels","size","will","object","total","of","learning","once","s","inputs","detailed","data","values","built","case","using","functional","}","identifiers","concepts","have","by","(","y","softmax","optimizer","'","and","what","outputs","type","how","relu","be","toy","from","optimizers","contains","1s","experimental","is","practice","example","1ms","before","our","keras","train","output","course","string","look","{","non","learns","build","shape","you","activation","rmsprop","_________________________________________________________________","get","happened","training","let","function","16512","since","per","classify","preprocessing","iterate","for","arrays","slices","params","these","2","]","used","samples","1","epochs","255",")","inputlayer","sparse","fit","batches","x","returns","argument","assume","their","1.0","1e","an","flatten","128","282","categoricalcrossentropy","looks","fitting","model","array","iterations","single","as","32","&","dense","[","categorical","records","input","test","batched","layers","scalar","100480","the","yielded","938","specified","sliced","\"","28","rescaling","are","times","mnist"," ","step","784","0.1156","start","in","expect","history"],"title":"Training models with fit()","title_tokens":["with","training"," ","models",")","fit","("]},{"location":"Skills/#games","text":"参考： https://www.zhihu.com/question/36702693 输出：？","text_tokens":["：","输出","/"," ","question","参考","www","zhihu","36702693","com","https",":",".","？"],"title":"games：","title_tokens":["：","games"]}]}